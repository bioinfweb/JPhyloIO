/*
 * JPhyloIO - Event based parsing and stream writing of multiple sequence alignment and tree formats. 
 * Copyright (C) 2015-2016  Ben St√∂ver, Sarah Wiechers
 * <http://bioinfweb.info/JPhyloIO>
 * 
 * This file is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This file is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
package info.bioinfweb.jphyloio.formats.newick;


import info.bioinfweb.jphyloio.events.ConcreteJPhyloIOEvent;
import info.bioinfweb.jphyloio.events.JPhyloIOEvent;
import info.bioinfweb.jphyloio.events.MetaInformationEvent;
import info.bioinfweb.jphyloio.events.type.EventContentType;
import info.bioinfweb.jphyloio.events.type.EventTopologyType;

import java.util.Collection;
import java.util.LinkedList;



/**
 * Reads meta information from a hot comment in a Newick string like it is generated by MrBayes or BEAST.
 * 
 * @author Ben St&ouml;ver
 */
public class HotCommentDataReader implements NewickConstants {
	private static class Value {
		public String stringValue;
		public Object objectValue;
		
		public Value(String stringValue, Object objectValue) {
			super();
			this.stringValue = stringValue;
			this.objectValue = objectValue;
		}
		
		public Value(String stringValue) {
			this(stringValue, stringValue);
		}
	}
	
	
	private Value readTextElementData(String text) {
		if ((text.startsWith(Character.toString(NAME_DELIMITER)) && text.endsWith(Character.toString(NAME_DELIMITER)))
				|| (text.startsWith(Character.toString(ALTERNATIVE_NAME_DELIMITER)) 
						&& text.endsWith(Character.toString(ALTERNATIVE_NAME_DELIMITER)))) {
			
			return new Value(text.substring(1, text.length() - 1));  // Values like "100" should also be read as a string.
		}
		else {
			try {  //TODO Should parsing a long be tried before?
				return new Value (text, new Double(text));
			}
			catch (NumberFormatException e) {
				return new Value(text);
			}
		}
	}
	
	
	private int findFieldEnd(String text, int pos) {
		while (pos < text.length()) {
			if (text.charAt(pos) == ALLOCATION_SEPARATOR_SYMBOL) {
				return pos;
			}
			else {
				pos++;
			}
		}
		return -1;
	}
	
	
	private int findAllocationEnd(String text, int start) {
		if (start >= text.length()) {
			return -1;
		}
		else {
			int pos = start;
			while (pos < text.length()) {
				switch (text.charAt(pos)) {
					case FIELD_START_SYMBOL:
						pos = findFieldEnd(text, pos);
						if (pos == -1) {
							return -1;
						}
						break;
					case ALLOCATION_SEPARATOR_SYMBOL:
						return pos;
				}
				pos++;
			}
			return pos;
		}
	}
	
	
	private void addMetaInformation(String key, Value value, Collection<JPhyloIOEvent> eventQueue, boolean addEndEvent) {
		eventQueue.add(new MetaInformationEvent(key, null, value.stringValue, value.objectValue));
		if (addEndEvent) {
			eventQueue.add(new ConcreteJPhyloIOEvent(EventContentType.META_INFORMATION, EventTopologyType.END));
		}
	}
	
	
	/**
	 * Processed comments according to 
	 * <a href="https://code.google.com/archive/p/beast-mcmc/wikis/NexusMetacommentFormat.wiki">this</a> definition.
	 * 
	 * @param comment
	 * @param eventQueue
	 */
	private void processMetacomments(final String comment, Collection<JPhyloIOEvent> eventQueue) {
		int start = 1;
		int end = findAllocationEnd(comment, start);  //TODO Is this still necessary? (Comes from TG implementation.)
		while (end != -1) {
			String[] parts = comment.substring(start, end).split("" + ALLOCATION_SYMBOL);
			if (parts.length == 2) {
				for (int j = 0; j < parts.length; j++) {
					parts[j] = parts[j].trim();
				}
				
				if (parts[1].startsWith("" + FIELD_START_SYMBOL)) {
					if (parts[1].endsWith("" + FIELD_END_SYMBOL)) {
						String[] values = parts[1].substring(1, parts[1].length() - 1).split(
								"" + FIELD_VALUE_SEPARATOR_SYMBOL);
						addMetaInformation(parts[0], new Value(null), eventQueue, false);
						for (int j = 0; j < values.length; j++) {
							addMetaInformation(parts[0] + INDEX_START_SYMBOL + j + INDEX_END_SYMBOL,  //TODO Use different key here? 
									readTextElementData(values[j].trim()), eventQueue, true);
						}
						eventQueue.add(new ConcreteJPhyloIOEvent(EventContentType.META_INFORMATION, EventTopologyType.END));
					}
				}
				else {
					addMetaInformation(parts[0], readTextElementData(parts[1]), eventQueue, true);
				}
			}
			
			start = end + 1;
			end = findAllocationEnd(comment, start);
		}
	}
	
	
	/**
	 * Processed comments according to 
	 * <a href="https://sites.google.com/site/cmzmasek/home/software/forester/nhx">this</a> definition.
	 * 
	 * @param comment
	 * @param eventQueue
	 */
	private void processNHX(final String comment, Collection<JPhyloIOEvent> eventQueue) {
		Collection<JPhyloIOEvent> newEvents = new LinkedList<JPhyloIOEvent>();
		String[] parts = comment.substring(NHX_START.length()).split("" + NHX_VALUE_SEPARATOR_SYMBOL);
		for (int i = 0; i < parts.length; i++) {
			int splitPos = parts[i].indexOf(ALLOCATION_SYMBOL);
			if (splitPos > 0) {
				addMetaInformation(NHX_KEY_PREFIX + parts[i].substring(0, splitPos), 
						readTextElementData(parts[i].substring(splitPos + 1, parts[i].length())), newEvents, true);  //TODO Modify key, e.g. using the analog from phyloXML?
			}
			else {  // If the part starts with '=' or there is no '='.
				throw new IllegalArgumentException("\"" + parts[i] + "\" is not a legal NHX metadata definition.");
			}
		}
		eventQueue.addAll(newEvents);
	}
	
	
	/**
	 * Reads metadata from the specified hot comment and adds according {@link MetaInformationEvent}s
	 * to the queue.
	 * <p>
	 * Array values are translated to nested metaevents.
	 * 
	 * @param comment the text of the hot comment without the comment start or end tokens
	 * @param eventQueue the event queue to add generated metaevents to
	 * @param isOnNode Specifies {@code true} here, if the hot comment was attached to a node or
	 *        {@code false} if it was attached to an edge
	 * @throws IllegalArgumentException if the specified comment cannot be parsed in the TreeAnnotator or the NHX format.
	 */
	public void read(String comment, Collection<JPhyloIOEvent> eventQueue, boolean isOnNode) throws IllegalArgumentException {
		if (comment.startsWith(NHX_START)) {  // Needs to be checked first.
			processNHX(comment, eventQueue);
		}
		else if (comment.startsWith("" + HOT_COMMENT_START_SYMBOL)) {
			processMetacomments(comment, eventQueue);
		}
		// The following case is currently unused, because JPhyloIO creates comment events from unnamed hot comments 
		// and its up to the application, whether these shall be interpreted as metainformation or not.
//		else if (comment.length() > 0) {  // Read unformatted comment
//			String name = UNNAMED_EDGE_DATA_NAME;
//			if (isOnNode) {
//				name = UNNAMED_NODE_DATA_NAME;
//			}
//			addMetaInformation(name, readTextElementData(comment), eventQueue, true);
//		}
	}
}